{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CSSE3010 Documentation Guides Git Guide","title":"Home"},{"location":"#csse3010_documentation","text":"","title":"CSSE3010 Documentation"},{"location":"#guides","text":"Git Guide","title":"Guides"},{"location":"code/code/","text":"","title":"Code"},{"location":"datasheet/datasheet/","text":"","title":"Datasheet"},{"location":"getting_started/blinky/","text":"Compiling your first app Getting Started navigate to sourcelib -> examples -> getting-started -> blink select your platform here, for most people this will be nucleo-f429. If you are an external student, you may have one of the other boards, check it carefully. Compiling Inside the platform folder, there should be a file called main.c and a file called Makefile . Execute the command: make All the c files should now start building, when it finishes, there will be a main.bin file, main.elf file, main.hex file, and main.o file, as well as an obj directory. Flashing Now that our code is compiled, it is time to flash it onto the nucleo, however there are a few steps we need to do before we can do so. Flashing the Nucleo with JLink The flashing tools used in this course rely on JLink libraries, JLink is used to communicate with the debugging chip on the board which will then flash the code (amongst doing other things). However the board dy default comes with a different debugging chip, ST-LINK Tips and Troubleshooting make clean cleans the compiled binaries, this is not always necessary when recompiling code, since not everything needs to be recompiled, however it is useful when a lot of changes have been made. make -j makes compiling faster by using all allocated cpu cores, note that when using a VM to make full use of this you would need to allocate more CPU cores in the VM settings if make complains about a .depend target, you open the makefile and change include .depend to -include .depend","title":"Blinky"},{"location":"getting_started/blinky/#compiling_your_first_app","text":"","title":"Compiling your first app"},{"location":"getting_started/blinky/#getting_started","text":"navigate to sourcelib -> examples -> getting-started -> blink select your platform here, for most people this will be nucleo-f429. If you are an external student, you may have one of the other boards, check it carefully.","title":"Getting Started"},{"location":"getting_started/blinky/#compiling","text":"Inside the platform folder, there should be a file called main.c and a file called Makefile . Execute the command: make All the c files should now start building, when it finishes, there will be a main.bin file, main.elf file, main.hex file, and main.o file, as well as an obj directory.","title":"Compiling"},{"location":"getting_started/blinky/#flashing","text":"Now that our code is compiled, it is time to flash it onto the nucleo, however there are a few steps we need to do before we can do so.","title":"Flashing"},{"location":"getting_started/blinky/#flashing_the_nucleo_with_jlink","text":"The flashing tools used in this course rely on JLink libraries, JLink is used to communicate with the debugging chip on the board which will then flash the code (amongst doing other things). However the board dy default comes with a different debugging chip, ST-LINK","title":"Flashing the Nucleo with JLink"},{"location":"getting_started/blinky/#tips_and_troubleshooting","text":"make clean cleans the compiled binaries, this is not always necessary when recompiling code, since not everything needs to be recompiled, however it is useful when a lot of changes have been made. make -j makes compiling faster by using all allocated cpu cores, note that when using a VM to make full use of this you would need to allocate more CPU cores in the VM settings if make complains about a .depend target, you open the makefile and change include .depend to -include .depend","title":"Tips and Troubleshooting"},{"location":"git/git/","text":"CSSE3010 Git Guide Use Git to manage your development. Benefit: Git is an distributed repository that you can use to keep track of your current code history and use for backup purposes. You can check in changes when you need to, not just when you are connected to the Internet. This means that your git history will be more like a \u201cworkbook\u201d or diary of your progress. There are 2 repositories you will need for this course 'sourcelib' - this contains all the necessary drivers needed to compile your code, as well as programming examples, Makefiles, compiling tools, flashing tools, and debugging tools. This repository is public, available to everyone, you will only be pulling from this repository. You can find the repository here https://github.com/uqembeddedsys/sourcelib , you will clone it further on in this guide. 'repo' - This is where you will commit your code, any libraries you develop, stage code, and project code goes here. This document contains instructions on the following procedures: Setting up your git account Initialising the repository locally (Do this the first time only) Public Key Generation (For automatic authentication) Cloning your online repository Adding a .gitignore file (Do this once only) Committing changes (Each time an element of work is done) Synchronizing your local repository with the online repository (after each stage/project) Summary Using the Git Command Line Interface (CLI) Troubleshooting Task 1: Setting up your git account Access to your gitea account is via your UQ login, using single sign on (SSO). Browse CSSE3010/CSSE7301 gitea using the URL: https://csse3010-gitea.uqcloud.net/ . Once logged in, you will see one empty 'repo' repository under your student number. Figure 1: Logging into CSSE3010/CSSE7301 Gitea for the first time This is your repo, all the code you write will be pushed here, all testing from projects and stages will be done by pulling from this repo. Task 2: Public Key Generation You will need to generate a public and private key pair. The public key will need to be uploaded to your Gitea account. This will allow your local git to be automatically authenticated to your online git account. Open a terminal and type the following commands: Generate key pair: ssh-keygen Add the key to the ssh-agent ssh-add ~/.ssh/id_rsa Display public key generated above: cat ~/.ssh/id_rsa.pub NOTE: press <enter> when asked for file location and pass-phrase. If you get asked if you want to overwrite the previous key, say 'yes'. You now need to link the public ssh key to your gitea account. Open gitea in your browser and navigate: Profile and Settings (Top Right Button) -> Settings -> SSH / GPG Keys -> Manage SSH Keys -> Add Key The url for the SSH settings should be https://csse3010-gitea.uqcloud.net/user/settings/keys Copy the contents of cat ~/.ssh/id_rsa.pub into the \"Content\" section. NOTE: For VirtualBox users, make sure \u201cclipboard, bidirectional\u201d is enabled, this will help you copy+paste things between your Host OS and VM. Task 3: Git Configuration You will need to initialize your git configuration and set up your global user name and user email. This is required to ensure that you can commit to your local repository. Open a terminal (in your Virtual Machine) and execute the following commands: git config --global user.name \"<MY.NAME>\" git config --global user.email MY.EMAIL@student.uq.edu.au NOTE: <MY.NAME> eg. \u201cjoe student\u201d. user.name is the name that will come up under your commit logs, user.email will link your git agent to your git-ea account. Task 4: Cloning Sourcelib Execute the following commands: - Change into home directory: cd ~ - Create a folder called csse3010: mkdir csse3010 - Change into your csse3010 directory: cd ~/csse3010 - Clone the remote sourcelib repository into your csse3010 folder. This will automatically create a folder called sourcelib: git clone https://github.com/uqembeddedsys/sourcelib.git Figure 2: Git URL for cloning sourcelib Task 5: Cloning Repo Navigate to 'repo' in gitea, select 'SSH', and copy the ssh url Figure 3: Git URL for cloning repo cd ~/csse3010 git clone <copied url> e.g. git@csse3010-gitea.zones.eait.uq.edu.au:12345678/repo.git There should now be 2 folders in ~/csse3010 , repo and sourcelib . You have now completed your local repository setup. You can now use git to commit your files. Note that committing files only stores files locally. It DOES NOT synchronise your local Git repository with your online repository. When using git, you can graphically see the current history by running gitg. NOTE: If you are working from home, you MUST be connected to the UQ VPN to be able to use git remotely, see the UQ VPN Guide NOTE: There WILL be updates to sourcelib throughout the semester, make sure you keep it up to date by cd ~/csse3010/sourcelib git fetch git pull , do this often. NOTE: there are two labels in your gitg window, a master branch and a origin/master branch. The master branch is on your local repository, and all branches prefixed with origin/ are on the remote server (CSSE3010/CSSE7301 gitea). NOTE: You will only commit files to the repo repository. Task 6: Staging and Pushing Files Under normal development, you can use git to stage files, and commit them to your repository. Make a commit now by updating the README.md file in your repo , if there is no README.md file, you can create one with touch README.md . Open the file with a text editor. e.g. code README.md , change the title to <Student#> 3010 Repo , e.g. 42345678 3010 Repo , save the file and close it. Open a terminal in the repo folder. git status git add README.md git commit -m\"updated README\" git push -u origin master Figure 4: git commit example Doing a git commit will create a commit in your local repository. Doing a git push will push the commit to your remote repository on gitea. You can do several git commits before doing a git push, if you so wish. Figure 5 shows the revised history after this commit. Figure 5: gitg commit history Summary of Important Commands check curret repo status git status view history: gitg commit files: git add , git commit To get the latest changes from the online repository: git fetch , git pull To push all your local commits to the online repository: git push (or git push -u origin master if pushing for the first time to an empty remote repository) If you are recovering from a HDD failure, use the commands in the original guide git clone <URL> Other tips Commit changes regularly. You will be required to put your changes into the online Gitea (AT LEAST) after each assessment, every session, including stage, project, etc. Troubleshooting Error: \"Could not resolve hostname https://csse3010-gitea.uqcloud.net/ : No address associated with host\" This URL should have been copied directly from the gitea web interface. Typing this manually has the potential to cause typos to exist. This problem may be caused by your VM not being connected to the Internet. - Make sure your computer (the \u201chost\u201d) is connected to the Internet. - Make sure you are connected to UQ VPN - Reboot your VM. - ping 8.8.8.8 - make sure you are getting packets - ping github.com - make sure DNS works ( fix ) - ssh-add -l check the ssh-key is listed in the ssh-agent, also check the fingerprint of the key matches the fingerprint in gitea - If all else fails, prepend GIT_SSH_COMMAND=\"ssh -vv\" before the git command, e.g. GIT_SSH_COMMAND=\"ssh -vv\" git clone -v git@csse3010-gitea.zones.eait.uq.edu.au:41234567/repo.git , then paste the output in Ed. Error: Unable to do a git pull \"Your local changes to the following files would be overwritten by merge: Please, commit your changes or stash them before you can merge. Aborting\" Reset your git and completely overwrite your local changes - NOTE: ALL YOUR CHANGES WILL BE DELETED AND REPLACED BY THE ONLINE GIT FILES. Run the following commands: git reset HEAD --hard git pull Alternatively git stash git pull git stash pop <fix any merge conflicts> git commit","title":"Git"},{"location":"git/git/#csse3010_git_guide","text":"Use Git to manage your development. Benefit: Git is an distributed repository that you can use to keep track of your current code history and use for backup purposes. You can check in changes when you need to, not just when you are connected to the Internet. This means that your git history will be more like a \u201cworkbook\u201d or diary of your progress. There are 2 repositories you will need for this course 'sourcelib' - this contains all the necessary drivers needed to compile your code, as well as programming examples, Makefiles, compiling tools, flashing tools, and debugging tools. This repository is public, available to everyone, you will only be pulling from this repository. You can find the repository here https://github.com/uqembeddedsys/sourcelib , you will clone it further on in this guide. 'repo' - This is where you will commit your code, any libraries you develop, stage code, and project code goes here. This document contains instructions on the following procedures: Setting up your git account Initialising the repository locally (Do this the first time only) Public Key Generation (For automatic authentication) Cloning your online repository Adding a .gitignore file (Do this once only) Committing changes (Each time an element of work is done) Synchronizing your local repository with the online repository (after each stage/project) Summary Using the Git Command Line Interface (CLI) Troubleshooting","title":"CSSE3010 Git Guide"},{"location":"git/git/#task_1_setting_up_your_git_account","text":"Access to your gitea account is via your UQ login, using single sign on (SSO). Browse CSSE3010/CSSE7301 gitea using the URL: https://csse3010-gitea.uqcloud.net/ . Once logged in, you will see one empty 'repo' repository under your student number. Figure 1: Logging into CSSE3010/CSSE7301 Gitea for the first time This is your repo, all the code you write will be pushed here, all testing from projects and stages will be done by pulling from this repo.","title":"Task 1: Setting up your git account"},{"location":"git/git/#task_2_public_key_generation","text":"You will need to generate a public and private key pair. The public key will need to be uploaded to your Gitea account. This will allow your local git to be automatically authenticated to your online git account. Open a terminal and type the following commands: Generate key pair: ssh-keygen Add the key to the ssh-agent ssh-add ~/.ssh/id_rsa Display public key generated above: cat ~/.ssh/id_rsa.pub NOTE: press <enter> when asked for file location and pass-phrase. If you get asked if you want to overwrite the previous key, say 'yes'. You now need to link the public ssh key to your gitea account. Open gitea in your browser and navigate: Profile and Settings (Top Right Button) -> Settings -> SSH / GPG Keys -> Manage SSH Keys -> Add Key The url for the SSH settings should be https://csse3010-gitea.uqcloud.net/user/settings/keys Copy the contents of cat ~/.ssh/id_rsa.pub into the \"Content\" section. NOTE: For VirtualBox users, make sure \u201cclipboard, bidirectional\u201d is enabled, this will help you copy+paste things between your Host OS and VM.","title":"Task 2: Public Key Generation"},{"location":"git/git/#task_3_git_configuration","text":"You will need to initialize your git configuration and set up your global user name and user email. This is required to ensure that you can commit to your local repository. Open a terminal (in your Virtual Machine) and execute the following commands: git config --global user.name \"<MY.NAME>\" git config --global user.email MY.EMAIL@student.uq.edu.au NOTE: <MY.NAME> eg. \u201cjoe student\u201d. user.name is the name that will come up under your commit logs, user.email will link your git agent to your git-ea account.","title":"Task 3: Git Configuration"},{"location":"git/git/#task_4_cloning_sourcelib","text":"Execute the following commands: - Change into home directory: cd ~ - Create a folder called csse3010: mkdir csse3010 - Change into your csse3010 directory: cd ~/csse3010 - Clone the remote sourcelib repository into your csse3010 folder. This will automatically create a folder called sourcelib: git clone https://github.com/uqembeddedsys/sourcelib.git Figure 2: Git URL for cloning sourcelib","title":"Task 4: Cloning Sourcelib"},{"location":"git/git/#task_5_cloning_repo","text":"Navigate to 'repo' in gitea, select 'SSH', and copy the ssh url Figure 3: Git URL for cloning repo cd ~/csse3010 git clone <copied url> e.g. git@csse3010-gitea.zones.eait.uq.edu.au:12345678/repo.git There should now be 2 folders in ~/csse3010 , repo and sourcelib . You have now completed your local repository setup. You can now use git to commit your files. Note that committing files only stores files locally. It DOES NOT synchronise your local Git repository with your online repository. When using git, you can graphically see the current history by running gitg. NOTE: If you are working from home, you MUST be connected to the UQ VPN to be able to use git remotely, see the UQ VPN Guide NOTE: There WILL be updates to sourcelib throughout the semester, make sure you keep it up to date by cd ~/csse3010/sourcelib git fetch git pull , do this often. NOTE: there are two labels in your gitg window, a master branch and a origin/master branch. The master branch is on your local repository, and all branches prefixed with origin/ are on the remote server (CSSE3010/CSSE7301 gitea). NOTE: You will only commit files to the repo repository.","title":"Task 5: Cloning Repo"},{"location":"git/git/#task_6_staging_and_pushing_files","text":"Under normal development, you can use git to stage files, and commit them to your repository. Make a commit now by updating the README.md file in your repo , if there is no README.md file, you can create one with touch README.md . Open the file with a text editor. e.g. code README.md , change the title to <Student#> 3010 Repo , e.g. 42345678 3010 Repo , save the file and close it. Open a terminal in the repo folder. git status git add README.md git commit -m\"updated README\" git push -u origin master Figure 4: git commit example Doing a git commit will create a commit in your local repository. Doing a git push will push the commit to your remote repository on gitea. You can do several git commits before doing a git push, if you so wish. Figure 5 shows the revised history after this commit. Figure 5: gitg commit history","title":"Task 6: Staging and Pushing Files"},{"location":"git/git/#summary_of_important_commands","text":"check curret repo status git status view history: gitg commit files: git add , git commit To get the latest changes from the online repository: git fetch , git pull To push all your local commits to the online repository: git push (or git push -u origin master if pushing for the first time to an empty remote repository) If you are recovering from a HDD failure, use the commands in the original guide git clone <URL>","title":"Summary of Important Commands"},{"location":"git/git/#other_tips","text":"Commit changes regularly. You will be required to put your changes into the online Gitea (AT LEAST) after each assessment, every session, including stage, project, etc.","title":"Other tips"},{"location":"git/git/#troubleshooting","text":"Error: \"Could not resolve hostname https://csse3010-gitea.uqcloud.net/ : No address associated with host\" This URL should have been copied directly from the gitea web interface. Typing this manually has the potential to cause typos to exist. This problem may be caused by your VM not being connected to the Internet. - Make sure your computer (the \u201chost\u201d) is connected to the Internet. - Make sure you are connected to UQ VPN - Reboot your VM. - ping 8.8.8.8 - make sure you are getting packets - ping github.com - make sure DNS works ( fix ) - ssh-add -l check the ssh-key is listed in the ssh-agent, also check the fingerprint of the key matches the fingerprint in gitea - If all else fails, prepend GIT_SSH_COMMAND=\"ssh -vv\" before the git command, e.g. GIT_SSH_COMMAND=\"ssh -vv\" git clone -v git@csse3010-gitea.zones.eait.uq.edu.au:41234567/repo.git , then paste the output in Ed. Error: Unable to do a git pull \"Your local changes to the following files would be overwritten by merge: Please, commit your changes or stash them before you can merge. Aborting\" Reset your git and completely overwrite your local changes - NOTE: ALL YOUR CHANGES WILL BE DELETED AND REPLACED BY THE ONLINE GIT FILES. Run the following commands: git reset HEAD --hard git pull Alternatively git stash git pull git stash pop <fix any merge conflicts> git commit","title":"Troubleshooting"},{"location":"hal/hal/","text":"","title":"Hal"},{"location":"mylib/mylib/","text":"MYLIB Guide Introduction The MyLib is a library folder that contains .c and .h files which you will develop for the external peripherals and commonly used library functions that you will use. External peripherals are devices that are not part of the microcontroller unit, i.e. LED Light-Bar or Joystick. Each time you use a peripheral you will create an associated MyLib file that contains the Application Interface (API) functions for that particular peripheral. Commonly used library functions are purely software based features, e.g. Hamming or CRC libraries. As you develop further code, you will continue to update the MyLib files by adding new functionalities required by the stages and projects. Mylib files should be developed in a way that will allow you to reuse your previously developed code for later stages and projects, without having to copy and paste peripheral code. Folder Structure To ensure all course materials and your own work are well organised, we require that you implement the folder hierarchy and naming conventions displayed in the figure below. \\hrule \\begin{flushleft} \\begin{forest} for tree={ font=\\ttfamily, grow'=0, folder, if n children=0{ before typesetting nodes={ tempdima=\\iconsepfrompath+\\iconsep+8 \\touchsize, content/.wrap value={\\expandafter\\hskip \\foresteregister{tempdima}#1}, }, tikz={% \\pic [xshift=\\iconsepfrompath] at (.west) {mkdir}; }, }{ if level=0{ tikz={% \\pic [xshift=\\iconsepfrompath] at (.west) {mkdir}; }, before typesetting nodes={ tempdima=\\iconsep+12 \\mkdirsize, content/.wrap value={\\expandafter\\hskip \\foresteregister{tempdima}#1}, }, }{ tikz={% \\pic [xshift=\\iconsepfrompath] at (.west) {mkdir}; }, before typesetting nodes={ tempdima=\\iconsepfrompath+\\iconsep+12*\\mkdirsize, content/.wrap value={\\expandafter\\hskip \\foresteregister{tempdima}#1}, }, }, }, }, [\\$HOME [csse3010 [sourcelib] [mylib [lta1000g] [joystick] ] [project] [stages [stage1 ] [stage2] ] ] ] \\end{forest} \\end{flushleft} \\hrule ~ First you will create a \\textbf{csse3010} folder under your home directory. This folder serves as your git group folder. Here, you must add the sourcelib, mylib, project and stage git repositories. You will need to clone the \\textbf{\\textbf{sourcelib}} repository, which contains the examples, HAL and OS library files. You will have to create the \\textbf{mylib}, \\textbf{project} and \\textbf{stage} git repositories. These will contain all of your work. The \\textbf{mylib} repository will contain all your mylib files. Each mylib driver will have its own folder, e.g. \\textbf{joystick}. The \\textbf{stage} repository will also contain a folder for each stage (named \\textbf{stage1}, \\textbf{stage2} etc.). Mylib Files and Folder Organisation {Mylib folder and files The mylib folder should contain source (.c) and header (.h) files, which are specific to a function or peripheral. Examples are seen in Table 1. There are 4 types of source (.c) and header (.h) files that you will use. \\begin{itemize} \\item Hardware Abstract Layer (\\textbf{HAL}) \u2013 contains low level hardware accessing functions. \\subitem - sxxxxxx_hal_peripheral.c/.h \\item Operating System (\\textbf{OS}) \u2013 contains OS specific functions (e.g. using the FreeRTOS functions) \\subitem - sxxxxxx_os_peripheral.c/.h \\item Command Line Interface (\\textbf{CLI}) \u2013 contains CLI functions (e.g. using the FreeRTOS CLI library functions) \\subitem - o sxxxxxx_cli_peripheral.c/.h \\item Library Function (\\textbf{LIB}) \u2013 contains commonly used functions that are not HAL, OS or CLI related functions. \\end{itemize} For guidelines for the OS and CLI mylib files, see the csse3010_mylib_os_peripheral_guide.pdf on Blackboard. \\begin{table}[H] \\centering \\caption{Example Files} \\renewcommand{\\arraystretch}{1} \\begin{tabular}{|p{5cm}|p{5cm}|} \\hline \\textbf{Peripheral} & \\textbf{File name} \\ \\hline LED Light Bar HAL & sxxxxxx_hal_lightbar.c \\ \\hline Joystick OS & sxxxxxx_os_joystick.c \\ \\hline Pan Tilt CLI & sxxxxxx_cli_pantilt.c \\ \\hline Hamming encoder/decoder & sxxxxxx_lib_hamming.c \\ \\hline \\end{tabular} %} \\end{table} Mylib HAL File Structure A mylib HAL .c file for a particular peripheral contains external functions to initialise, utilise (get or set) and control that peripheral. Internal functions can also be present in mylib .c files. External and internal functions and their naming convention are elaborated on below in section \\ref{ref:convention}. Each mylib .c file must contain an \\texttt{init()} function and a \\texttt{deinit()} function, which contain the initialisation an de-initialisation code for that particular peripheral. Mylib LIB File Structure A mylib LIB .c file contains external functions for commonly used features. There are no required functions. Internal functions can also be present in these filess. Mylib File and Header Description Section Each mylib source file (.c) must contain a top comment section at the beginning of the file that states the purpose of the file the external functions defined within. An example is given below. The mylib header file (.h) should also contain the descriptive section and list of external functions. \\ /** *************************************************************** * @file mylib/ledbar/sxxxxxx_hal_ledbar.c * @author MyName - MyStudent ID * @date 22022018 * @brief MY peripheral driver * REFERENCE: DON'T JUST COPY THIS BLINDLY.pdf *************************************************************** * EXTERNAL FUNCTIONS *************************************************************** * sxxxxxx_hal_my_init() - intialise LED bar * sxxxxxx_hal_my_set() - set LED bar value *************************************************************** */ Mylib Naming Conventions Naming conventions for mylib files and external and internal functions. File Naming Convention Files must contain your student login (sxxxxxx) and the name of the peripheral. The name must be lower case. For example: sxxxxxx_hal_peripheral.c External Function Naming Convention External functions are called outside the .c file in which they are defined. External functions must contain your student login (sxxxxxx), the HAL/OS/CLI/LIB prefix, the name of the file and the purpose of the function. The name must be lower case. External functions should be declared in the corresponding header (.h) file with the \\textbf{extern} descriptor (template below). \\hfill \\break \\textbf{extern \\textcolor{green}{sxxxxxx}_hal_\\textcolor{blue}{peripheral}_function()} \\ For example: The function for getting the joystick x value (returns an unsigned short) defined in \\texttt{s123456_hal_joystick.c} should be named \\ extern unsigned short s123456_hal_joystick_getx() Table 2 contains naming suggestions for external functions commonly found in a mylib HAL file. \\begin{table}[H] \\centering \\caption{HAL Peripheral Driver External Functions} \\renewcommand{\\arraystretch}{1} \\begin{tabular}{|p{3cm}|p{8cm}|} \\hline \\textbf{Function Name} & \\textbf{Purpose} \\ \\hline \\texttt{_init()} & Initialise and configure peripheral (i.e. set GPIO pins, ADC parameters, etc.) \\ \\hline \\texttt{_read()} & Read value(s) \\ \\hline \\texttt{_write()} & Write value(s) \\ \\hline \\texttt{_ctrl()} & Change configuration parameters (different to \\texttt{init()}) \\ \\hline \\texttt{_deinit()} & De-initialise the peripheral (i.e. disable peripheral interrupts and shut down peripheral) \\ \\hline \\end{tabular} %} \\end{table} Internal Function Naming Convention Internal functions are only called within the file in which they are defined. Internal functions should only contain the name of the peripheral file and the purpose of the function. The name must be lower case (template below). \\ \\textbf{\\textcolor{blue}{peripheral}_function()} \\ For example: The function for converting joystick ADC value to voltage (returns an unsigned short) located in \\texttt{s123456_joystick.c} should be named\\ unsigned short joystick_adc2voltage(unsigned short raw_adc) Header File Header (.h) files should have the same name as the .c file. Header files need to begin with a \\textbf{#ifdef} statement and end with \\textbf{#endif}, to prevent re-entrancy errors. \\ #ifndef SXXXXXX_HAL_HEADERNAME_H #define SXXXXXX_HAL_HEADERNAME_H /* Header file code */ #endif","title":"MYLIB Guide"},{"location":"mylib/mylib/#mylib_guide","text":"","title":"MYLIB Guide"},{"location":"mylib/mylib/#introduction","text":"The MyLib is a library folder that contains .c and .h files which you will develop for the external peripherals and commonly used library functions that you will use. External peripherals are devices that are not part of the microcontroller unit, i.e. LED Light-Bar or Joystick. Each time you use a peripheral you will create an associated MyLib file that contains the Application Interface (API) functions for that particular peripheral. Commonly used library functions are purely software based features, e.g. Hamming or CRC libraries. As you develop further code, you will continue to update the MyLib files by adding new functionalities required by the stages and projects. Mylib files should be developed in a way that will allow you to reuse your previously developed code for later stages and projects, without having to copy and paste peripheral code.","title":"Introduction"},{"location":"mylib/mylib/#folder_structure","text":"To ensure all course materials and your own work are well organised, we require that you implement the folder hierarchy and naming conventions displayed in the figure below. \\hrule \\begin{flushleft} \\begin{forest} for tree={ font=\\ttfamily, grow'=0, folder, if n children=0{ before typesetting nodes={ tempdima=\\iconsepfrompath+\\iconsep+8 \\touchsize, content/.wrap value={\\expandafter\\hskip \\foresteregister{tempdima}#1}, }, tikz={% \\pic [xshift=\\iconsepfrompath] at (.west) {mkdir}; }, }{ if level=0{ tikz={% \\pic [xshift=\\iconsepfrompath] at (.west) {mkdir}; }, before typesetting nodes={ tempdima=\\iconsep+12 \\mkdirsize, content/.wrap value={\\expandafter\\hskip \\foresteregister{tempdima}#1}, }, }{ tikz={% \\pic [xshift=\\iconsepfrompath] at (.west) {mkdir}; }, before typesetting nodes={ tempdima=\\iconsepfrompath+\\iconsep+12*\\mkdirsize, content/.wrap value={\\expandafter\\hskip \\foresteregister{tempdima}#1}, }, }, }, }, [\\$HOME [csse3010 [sourcelib] [mylib [lta1000g] [joystick] ] [project] [stages [stage1 ] [stage2] ] ] ] \\end{forest} \\end{flushleft} \\hrule ~ First you will create a \\textbf{csse3010} folder under your home directory. This folder serves as your git group folder. Here, you must add the sourcelib, mylib, project and stage git repositories. You will need to clone the \\textbf{\\textbf{sourcelib}} repository, which contains the examples, HAL and OS library files. You will have to create the \\textbf{mylib}, \\textbf{project} and \\textbf{stage} git repositories. These will contain all of your work. The \\textbf{mylib} repository will contain all your mylib files. Each mylib driver will have its own folder, e.g. \\textbf{joystick}. The \\textbf{stage} repository will also contain a folder for each stage (named \\textbf{stage1}, \\textbf{stage2} etc.).","title":"Folder Structure"},{"location":"mylib/mylib/#mylib_files_and_folder_organisation","text":"","title":"Mylib Files and Folder Organisation"},{"location":"mylib/mylib/#mylib_folder_and_files","text":"The mylib folder should contain source (.c) and header (.h) files, which are specific to a function or peripheral. Examples are seen in Table 1. There are 4 types of source (.c) and header (.h) files that you will use. \\begin{itemize} \\item Hardware Abstract Layer (\\textbf{HAL}) \u2013 contains low level hardware accessing functions. \\subitem - sxxxxxx_hal_peripheral.c/.h \\item Operating System (\\textbf{OS}) \u2013 contains OS specific functions (e.g. using the FreeRTOS functions) \\subitem - sxxxxxx_os_peripheral.c/.h \\item Command Line Interface (\\textbf{CLI}) \u2013 contains CLI functions (e.g. using the FreeRTOS CLI library functions) \\subitem - o sxxxxxx_cli_peripheral.c/.h \\item Library Function (\\textbf{LIB}) \u2013 contains commonly used functions that are not HAL, OS or CLI related functions. \\end{itemize} For guidelines for the OS and CLI mylib files, see the csse3010_mylib_os_peripheral_guide.pdf on Blackboard. \\begin{table}[H] \\centering \\caption{Example Files} \\renewcommand{\\arraystretch}{1} \\begin{tabular}{|p{5cm}|p{5cm}|} \\hline \\textbf{Peripheral} & \\textbf{File name} \\ \\hline LED Light Bar HAL & sxxxxxx_hal_lightbar.c \\ \\hline Joystick OS & sxxxxxx_os_joystick.c \\ \\hline Pan Tilt CLI & sxxxxxx_cli_pantilt.c \\ \\hline Hamming encoder/decoder & sxxxxxx_lib_hamming.c \\ \\hline \\end{tabular} %} \\end{table}","title":"{Mylib folder and files"},{"location":"mylib/mylib/#mylib_hal_file_structure","text":"A mylib HAL .c file for a particular peripheral contains external functions to initialise, utilise (get or set) and control that peripheral. Internal functions can also be present in mylib .c files. External and internal functions and their naming convention are elaborated on below in section \\ref{ref:convention}. Each mylib .c file must contain an \\texttt{init()} function and a \\texttt{deinit()} function, which contain the initialisation an de-initialisation code for that particular peripheral.","title":"Mylib HAL File Structure"},{"location":"mylib/mylib/#mylib_lib_file_structure","text":"A mylib LIB .c file contains external functions for commonly used features. There are no required functions. Internal functions can also be present in these filess.","title":"Mylib LIB File Structure"},{"location":"mylib/mylib/#mylib_file_and_header_description_section","text":"Each mylib source file (.c) must contain a top comment section at the beginning of the file that states the purpose of the file the external functions defined within. An example is given below. The mylib header file (.h) should also contain the descriptive section and list of external functions. \\ /** *************************************************************** * @file mylib/ledbar/sxxxxxx_hal_ledbar.c * @author MyName - MyStudent ID * @date 22022018 * @brief MY peripheral driver * REFERENCE: DON'T JUST COPY THIS BLINDLY.pdf *************************************************************** * EXTERNAL FUNCTIONS *************************************************************** * sxxxxxx_hal_my_init() - intialise LED bar * sxxxxxx_hal_my_set() - set LED bar value *************************************************************** */","title":"Mylib File and Header Description Section"},{"location":"mylib/mylib/#mylib_naming_conventions","text":"Naming conventions for mylib files and external and internal functions.","title":"Mylib Naming Conventions"},{"location":"mylib/mylib/#file_naming_convention","text":"Files must contain your student login (sxxxxxx) and the name of the peripheral. The name must be lower case. For example: sxxxxxx_hal_peripheral.c","title":"File Naming Convention"},{"location":"mylib/mylib/#external_function_naming_convention","text":"External functions are called outside the .c file in which they are defined. External functions must contain your student login (sxxxxxx), the HAL/OS/CLI/LIB prefix, the name of the file and the purpose of the function. The name must be lower case. External functions should be declared in the corresponding header (.h) file with the \\textbf{extern} descriptor (template below). \\hfill \\break \\textbf{extern \\textcolor{green}{sxxxxxx}_hal_\\textcolor{blue}{peripheral}_function()} \\ For example: The function for getting the joystick x value (returns an unsigned short) defined in \\texttt{s123456_hal_joystick.c} should be named \\ extern unsigned short s123456_hal_joystick_getx() Table 2 contains naming suggestions for external functions commonly found in a mylib HAL file. \\begin{table}[H] \\centering \\caption{HAL Peripheral Driver External Functions} \\renewcommand{\\arraystretch}{1} \\begin{tabular}{|p{3cm}|p{8cm}|} \\hline \\textbf{Function Name} & \\textbf{Purpose} \\ \\hline \\texttt{_init()} & Initialise and configure peripheral (i.e. set GPIO pins, ADC parameters, etc.) \\ \\hline \\texttt{_read()} & Read value(s) \\ \\hline \\texttt{_write()} & Write value(s) \\ \\hline \\texttt{_ctrl()} & Change configuration parameters (different to \\texttt{init()}) \\ \\hline \\texttt{_deinit()} & De-initialise the peripheral (i.e. disable peripheral interrupts and shut down peripheral) \\ \\hline \\end{tabular} %} \\end{table}","title":"External Function Naming Convention"},{"location":"mylib/mylib/#internal_function_naming_convention","text":"Internal functions are only called within the file in which they are defined. Internal functions should only contain the name of the peripheral file and the purpose of the function. The name must be lower case (template below). \\ \\textbf{\\textcolor{blue}{peripheral}_function()} \\ For example: The function for converting joystick ADC value to voltage (returns an unsigned short) located in \\texttt{s123456_joystick.c} should be named\\ unsigned short joystick_adc2voltage(unsigned short raw_adc)","title":"Internal Function Naming Convention"},{"location":"mylib/mylib/#header_file","text":"Header (.h) files should have the same name as the .c file. Header files need to begin with a \\textbf{#ifdef} statement and end with \\textbf{#endif}, to prevent re-entrancy errors. \\ #ifndef SXXXXXX_HAL_HEADERNAME_H #define SXXXXXX_HAL_HEADERNAME_H /* Header file code */ #endif","title":"Header File"},{"location":"setup/linux/linux/","text":"Native Linux Setup Guide Overview Linux Installation - Install CSSE3010 source and tools directly on Ubuntu (Not using a VM). You can install the CSSE3010 source and toolchain onto Ubuntu, directly. NOTE: You must first have your git account setup BEFORE attempting this. NOTE: ONLY USE THIS GUIDE IF YOU ARE NOT USING A VIRTUAL MACHINE Ubuntu Automatic Script installation The automatic script will download and install the required packages, add the sourcelib_env.sh script to your .bashrc startup script and add your user name to the \u201cdialout\u201d group. Clone the sourcelib repository into your csse3010 directory using git clone Go to the sourcelib/tools folder Run the script sourcelib_install.sh as root \u2013 i.e. sudo ./sourcelib_install.sh The script will download and install part of the toolchain Run source ~/.profile Type echo $SOURCELIB_ROOT into your terminal. This command should return a path variable, i.e ~/csse3010/sourcelib Installing the GNU Arm Embedded Toolchain The GNU Arm Embedded Toolchain contains a compatible compiler for our MCU, while the utilities provided by STLink allows us to flash the Nucleo via the on-board STLinkV2 programmer. Download the latest version of GNU Arm Embedded Toolchain for your OS via https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads Run the following commands in your terminal: change into the home directory and make a new folder called tools cd ~; mkdir tools change into the directory where the file was downloaded into, Downloads is used here as an example, it could be called something different on your machine cd ~/Downloads extract the tar file into the tools folder that we created earlier tar -xjf <NAME_OF_DOWNLOADED_FILE> -C ~/tools NOTE: Normally you'd need to add the executable folder to PATH but that had already been taken care of by the install script in step 3 of the previous section. test it with arm-none-eabi-gcc --version","title":"Native Linux Setup Installation"},{"location":"setup/linux/linux/#native_linux_setup_guide","text":"","title":"Native Linux Setup Guide"},{"location":"setup/linux/linux/#overview","text":"Linux Installation - Install CSSE3010 source and tools directly on Ubuntu (Not using a VM). You can install the CSSE3010 source and toolchain onto Ubuntu, directly. NOTE: You must first have your git account setup BEFORE attempting this. NOTE: ONLY USE THIS GUIDE IF YOU ARE NOT USING A VIRTUAL MACHINE","title":"Overview"},{"location":"setup/linux/linux/#ubuntu_automatic_script_installation","text":"The automatic script will download and install the required packages, add the sourcelib_env.sh script to your .bashrc startup script and add your user name to the \u201cdialout\u201d group. Clone the sourcelib repository into your csse3010 directory using git clone Go to the sourcelib/tools folder Run the script sourcelib_install.sh as root \u2013 i.e. sudo ./sourcelib_install.sh The script will download and install part of the toolchain Run source ~/.profile Type echo $SOURCELIB_ROOT into your terminal. This command should return a path variable, i.e ~/csse3010/sourcelib","title":"Ubuntu Automatic Script installation"},{"location":"setup/linux/linux/#installing_the_gnu_arm_embedded_toolchain","text":"The GNU Arm Embedded Toolchain contains a compatible compiler for our MCU, while the utilities provided by STLink allows us to flash the Nucleo via the on-board STLinkV2 programmer. Download the latest version of GNU Arm Embedded Toolchain for your OS via https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads Run the following commands in your terminal: change into the home directory and make a new folder called tools cd ~; mkdir tools change into the directory where the file was downloaded into, Downloads is used here as an example, it could be called something different on your machine cd ~/Downloads extract the tar file into the tools folder that we created earlier tar -xjf <NAME_OF_DOWNLOADED_FILE> -C ~/tools NOTE: Normally you'd need to add the executable folder to PATH but that had already been taken care of by the install script in step 3 of the previous section. test it with arm-none-eabi-gcc --version","title":"Installing the GNU Arm Embedded Toolchain"},{"location":"setup/tips/tips/","text":"","title":"Tips"},{"location":"setup/virtual_machine/virtual_machine/","text":"Virtual Machine Setup Guide CSSE3010 Linux Virtual Machine (VM) Requirements Install CSSE3010 VM on VMware Player Pro (Windows) Install CSSE3010 VM on VirtualBox (OSX or Windows) Linux Virtual Machine Requirements You will require at least 8GB of hard-disk space, to install the VM. The Following Virtual Machines are recommended or the following operating systems: Windows: VMWare Player (preferred) or Virtual Box (alternate) OSX: Virtual Box or VMWare Fusion VMware Player Pro Installation: (Windows) You will be provided with a folder or links containing the VMWare workshop player installer and VM disk image file (.VDMK). Copy both to your hard drive. You can choose to download the latest VMware workshop player/ Install VMWare workshop player on your laptop. Step 1 You will now need to install the CSSE3010VM.VDMK file as a hard drive. Click, create a new virtual machine Click, create a new virtual machine Step 2 In new virtual machine wizard, select \"I will install the operating system later.\". \\includegraphics[width=0.7\\textwidth]{images/Picture2.png} | | |:--:| Step 3 In \"guest operating system\", select Linux and set the \"Version\" to be Ubuntu click next. Step 4 Set the \"Virtual machine name:\" to be CSSE3010VM. Step 5 Set the \"Maximum disk size\" to be 20GB. Select the \"Store virtual disk as a single file\". | | |:--:|] Step 6 Check your settings are correct and click finish. Step 7 Select \"CSSE3010VM\", under \"Home\", in the main portal and click \"edit virtual machine settings\". Step 8 Select the \u201cHard Disk (SCSI) 20GB\u201d Click \u201cRemove\u201d (The 20GB Hard Drive MUST BE REMOVED before proceeding) Click \"Add\" and continue to step 13) Step 9 Select \"Hard disk\", in \"Hardware types\". Step 10 Select \u201cSCSI\u201d. Step 11 Select \"use an existing virtual disk\" in \"Select a disk\". Click Next. Step 12 Click Browse and select your CSSE3010vm.vdmk file. Click Finish. Step 13 Now click \"play virtual machine\". Step 14 Your Virtual Machine should now boot. VirtualBox Installation: (OSX or Windows) You will be provided with a folder containing the VirtualBox installer and VM .VDMK file image. Copy both to your hard drive. Install VirtualBox on your laptop. } Next we are going to set up a new machine to run our Linux VM in by clicking \u2018New\u2019 up in the top left menu bar. Step 1 Click Next, input the name as \u2018CSSE3010\u2019 and select your OS as Linux, version Ubuntu and then click Next. SELECT OPERATING SYSTEM: LINUX and VERSION: UBUNTU-64bit Step 2 Now you have to set the amount of RAM to be allocated to the VM, 512MB is a good base. Hit Next. Step 3 We will select the start-up hard disk for the system to be the provided .vmdk file. This file will set up your VM to have all of the libraries, programs and other necessary files already set up. Click \u2018Use existing hard disk\u2019 then click the browse button as highlighted. Then navigate to and Open the ubuntu_vm.vmdk provided. Step 4 Your new machine should now appear in the VirtualBox main window, double click the icon to boot it up. Click OK through the dialogs that open and if prompted, log in as \u2018csse3010 with password \u2018csse3010. You should now see a desktop screen similar to this:","title":"Virtual Machine"},{"location":"setup/virtual_machine/virtual_machine/#virtual_machine_setup_guide","text":"CSSE3010 Linux Virtual Machine (VM) Requirements Install CSSE3010 VM on VMware Player Pro (Windows) Install CSSE3010 VM on VirtualBox (OSX or Windows)","title":"Virtual Machine Setup Guide"},{"location":"setup/virtual_machine/virtual_machine/#linux_virtual_machine_requirements","text":"You will require at least 8GB of hard-disk space, to install the VM. The Following Virtual Machines are recommended or the following operating systems: Windows: VMWare Player (preferred) or Virtual Box (alternate) OSX: Virtual Box or VMWare Fusion","title":"Linux Virtual Machine Requirements"},{"location":"setup/virtual_machine/virtual_machine/#vmware_player_pro_installation_windows","text":"You will be provided with a folder or links containing the VMWare workshop player installer and VM disk image file (.VDMK). Copy both to your hard drive. You can choose to download the latest VMware workshop player/ Install VMWare workshop player on your laptop.","title":"VMware Player Pro Installation: (Windows)"},{"location":"setup/virtual_machine/virtual_machine/#step_1","text":"You will now need to install the CSSE3010VM.VDMK file as a hard drive. Click, create a new virtual machine Click, create a new virtual machine","title":"Step 1"},{"location":"setup/virtual_machine/virtual_machine/#step_2","text":"In new virtual machine wizard, select \"I will install the operating system later.\". \\includegraphics[width=0.7\\textwidth]{images/Picture2.png} | | |:--:|","title":"Step 2"},{"location":"setup/virtual_machine/virtual_machine/#step_3","text":"In \"guest operating system\", select Linux and set the \"Version\" to be Ubuntu click next.","title":"Step 3"},{"location":"setup/virtual_machine/virtual_machine/#step_4","text":"Set the \"Virtual machine name:\" to be CSSE3010VM.","title":"Step 4"},{"location":"setup/virtual_machine/virtual_machine/#step_5","text":"Set the \"Maximum disk size\" to be 20GB. Select the \"Store virtual disk as a single file\". | | |:--:|]","title":"Step 5"},{"location":"setup/virtual_machine/virtual_machine/#step_6","text":"Check your settings are correct and click finish.","title":"Step 6"},{"location":"setup/virtual_machine/virtual_machine/#step_7","text":"Select \"CSSE3010VM\", under \"Home\", in the main portal and click \"edit virtual machine settings\".","title":"Step 7"},{"location":"setup/virtual_machine/virtual_machine/#step_8","text":"Select the \u201cHard Disk (SCSI) 20GB\u201d Click \u201cRemove\u201d (The 20GB Hard Drive MUST BE REMOVED before proceeding) Click \"Add\" and continue to step 13)","title":"Step 8"},{"location":"setup/virtual_machine/virtual_machine/#step_9","text":"Select \"Hard disk\", in \"Hardware types\".","title":"Step 9"},{"location":"setup/virtual_machine/virtual_machine/#step_10","text":"Select \u201cSCSI\u201d.","title":"Step 10"},{"location":"setup/virtual_machine/virtual_machine/#step_11","text":"Select \"use an existing virtual disk\" in \"Select a disk\". Click Next.","title":"Step 11"},{"location":"setup/virtual_machine/virtual_machine/#step_12","text":"Click Browse and select your CSSE3010vm.vdmk file. Click Finish.","title":"Step 12"},{"location":"setup/virtual_machine/virtual_machine/#step_13","text":"Now click \"play virtual machine\".","title":"Step 13"},{"location":"setup/virtual_machine/virtual_machine/#step_14","text":"Your Virtual Machine should now boot.","title":"Step 14"},{"location":"setup/virtual_machine/virtual_machine/#virtualbox_installation_osx_or_windows","text":"You will be provided with a folder containing the VirtualBox installer and VM .VDMK file image. Copy both to your hard drive. Install VirtualBox on your laptop. } Next we are going to set up a new machine to run our Linux VM in by clicking \u2018New\u2019 up in the top left menu bar.","title":"VirtualBox Installation: (OSX or Windows)"},{"location":"setup/virtual_machine/virtual_machine/#step_15","text":"Click Next, input the name as \u2018CSSE3010\u2019 and select your OS as Linux, version Ubuntu and then click Next. SELECT OPERATING SYSTEM: LINUX and VERSION: UBUNTU-64bit","title":"Step 1"},{"location":"setup/virtual_machine/virtual_machine/#step_16","text":"Now you have to set the amount of RAM to be allocated to the VM, 512MB is a good base. Hit Next.","title":"Step 2"},{"location":"setup/virtual_machine/virtual_machine/#step_17","text":"We will select the start-up hard disk for the system to be the provided .vmdk file. This file will set up your VM to have all of the libraries, programs and other necessary files already set up. Click \u2018Use existing hard disk\u2019 then click the browse button as highlighted. Then navigate to and Open the ubuntu_vm.vmdk provided.","title":"Step 3"},{"location":"setup/virtual_machine/virtual_machine/#step_18","text":"Your new machine should now appear in the VirtualBox main window, double click the icon to boot it up. Click OK through the dialogs that open and if prompted, log in as \u2018csse3010 with password \u2018csse3010. You should now see a desktop screen similar to this:","title":"Step 4"},{"location":"setup/windows/windows/","text":"","title":"Windows"},{"location":"workbook/workbook/","text":"Workbook Guide Workbook Overview The workbook is an important tool in engineering development. It must be used to record key facts, features and outcomes of a project. Workbooks are also seen as legal documents that can be used as evidence, e.g. patent applications. The workbook must be used to record how you design, implement and test your stages/projects. The workbook consists of the following sections for a each stage/project: Stage Worksheet (printout must be fully pasted into workbook). Printouts must be cut down to size and NOT folded or half pasted into the workbook. Stage/Project Criteria (printout pasted into workbook) Stage/Project Objectives (MUST BE DATED) Hardware Schematic Diagram sheets using the Hardware Schematic Template Program Flow Charts using the Flow Chart Template Operating State Diagrams (if required) using the State Diagram Template Testing Procedure Results and Conclusions Workbook Format and Use The workbook must be an A4 sized closed bound book, not spiral bound. Spiral bound books are NOT accepted. The workbook must only be used for the stages and projects. It MUST not be used for other purposes. Figure 1: Acceptable and Not Acceptable Workbooks Stage Worksheet and Criteria The stage worksheet must be printed and pasted into your workbook. The criteria must also be printed and pasted into your workbook (from stage worksheet). The criteria is used to record your marks for the stage. Objectives State the objectives of the stage/project. You should clearly state in one to five points what the end deliverables of the stage/project are. This should be derived from the stage/project description and tasks. This section must be dated. Templates Schematic Flowcharts State Diagrams Testing Your design must be tested to show it meets the objectives of the stage/project. This can be done by applying certain test patterns, e.g. Hamming sequences or using an instrument (Logic Analyser) to view an output. You should briefly outline how you will test your design and what tools you will use. Results and Conclusions You must state if your design was successful or not. You should also outline if there were any significant outcomes, problems or new facts that you need to be aware of.","title":"Workbook Guide"},{"location":"workbook/workbook/#workbook_guide","text":"","title":"Workbook Guide"},{"location":"workbook/workbook/#workbook_overview","text":"The workbook is an important tool in engineering development. It must be used to record key facts, features and outcomes of a project. Workbooks are also seen as legal documents that can be used as evidence, e.g. patent applications. The workbook must be used to record how you design, implement and test your stages/projects. The workbook consists of the following sections for a each stage/project: Stage Worksheet (printout must be fully pasted into workbook). Printouts must be cut down to size and NOT folded or half pasted into the workbook. Stage/Project Criteria (printout pasted into workbook) Stage/Project Objectives (MUST BE DATED) Hardware Schematic Diagram sheets using the Hardware Schematic Template Program Flow Charts using the Flow Chart Template Operating State Diagrams (if required) using the State Diagram Template Testing Procedure Results and Conclusions","title":"Workbook Overview"},{"location":"workbook/workbook/#workbook_format_and_use","text":"The workbook must be an A4 sized closed bound book, not spiral bound. Spiral bound books are NOT accepted. The workbook must only be used for the stages and projects. It MUST not be used for other purposes. Figure 1: Acceptable and Not Acceptable Workbooks","title":"Workbook Format and Use"},{"location":"workbook/workbook/#stage_worksheet_and_criteria","text":"The stage worksheet must be printed and pasted into your workbook. The criteria must also be printed and pasted into your workbook (from stage worksheet). The criteria is used to record your marks for the stage.","title":"Stage Worksheet and Criteria"},{"location":"workbook/workbook/#objectives","text":"State the objectives of the stage/project. You should clearly state in one to five points what the end deliverables of the stage/project are. This should be derived from the stage/project description and tasks. This section must be dated.","title":"Objectives"},{"location":"workbook/workbook/#templates","text":"Schematic Flowcharts State Diagrams","title":"Templates"},{"location":"workbook/workbook/#testing","text":"Your design must be tested to show it meets the objectives of the stage/project. This can be done by applying certain test patterns, e.g. Hamming sequences or using an instrument (Logic Analyser) to view an output. You should briefly outline how you will test your design and what tools you will use.","title":"Testing"},{"location":"workbook/workbook/#results_and_conclusions","text":"You must state if your design was successful or not. You should also outline if there were any significant outcomes, problems or new facts that you need to be aware of.","title":"Results and Conclusions"},{"location":"workbook/flowcharts/flowcharts/","text":"Flow Charts Flow charts show how the program's firmware is implemented. Multiple flow charts should be used to show how the firmware operates. Typically, a flow chart is drawn for each function created in the program. A single large flow chart is not acceptable. Each function should have a separate flow chart, e.g. \\texttt{main()}. An Interrupt Service Routine (ISR) should be drawn as a normal flow chart but must have an \"lightning\" symbol \\text{\\faBolt}, at the end of the start block, to show that the ISR can occur anytime.\\ The flow chart diagram sheet is used to show the flow charts used in your stage/project. Each flow chart diagram sheet must be pasted into your workbook. Each program implemented should have at least one flow chart diagram sheet. Note a program can consist (and often do) of more than one flow chart. Each flow chart diagram sheet must have a unique ID (FID) that consists of the stage number and a unique ID for the program - e.g. F3-1 is function 1 from Stage 3. If flow charts need to be segmented, then the flow chart FID must be used to reference the corresponding flow chart. \\ Refer to the Miller Flowchart guide on Blackboard for the required symbols. mylib For mylib components - the mylib sheet will specify which ID prefix to use e.g. joystick mylib HAL flow chart ID starts with JH-1. Each mylib component should consist of at least one flow chart. If flow charts need to be segmented, then the flow chart ID must be used to reference the corresponding flow chart. Figure 1: Flowchart Example [Miller] Segmentation Flow charts should at most take up one page. It is not acceptable for a flow chart to go over a page. Any flow chart taking up more than one page should be segmented into smaller flow charts. You can then combine them to construct a higher-level flow chart by referencing their IDs.","title":"Flow Charts"},{"location":"workbook/flowcharts/flowcharts/#flow_charts","text":"Flow charts show how the program's firmware is implemented. Multiple flow charts should be used to show how the firmware operates. Typically, a flow chart is drawn for each function created in the program. A single large flow chart is not acceptable. Each function should have a separate flow chart, e.g. \\texttt{main()}. An Interrupt Service Routine (ISR) should be drawn as a normal flow chart but must have an \"lightning\" symbol \\text{\\faBolt}, at the end of the start block, to show that the ISR can occur anytime.\\ The flow chart diagram sheet is used to show the flow charts used in your stage/project. Each flow chart diagram sheet must be pasted into your workbook. Each program implemented should have at least one flow chart diagram sheet. Note a program can consist (and often do) of more than one flow chart. Each flow chart diagram sheet must have a unique ID (FID) that consists of the stage number and a unique ID for the program - e.g. F3-1 is function 1 from Stage 3. If flow charts need to be segmented, then the flow chart FID must be used to reference the corresponding flow chart. \\ Refer to the Miller Flowchart guide on Blackboard for the required symbols.","title":"Flow Charts"},{"location":"workbook/flowcharts/flowcharts/#mylib","text":"For mylib components - the mylib sheet will specify which ID prefix to use e.g. joystick mylib HAL flow chart ID starts with JH-1. Each mylib component should consist of at least one flow chart. If flow charts need to be segmented, then the flow chart ID must be used to reference the corresponding flow chart. Figure 1: Flowchart Example [Miller]","title":"mylib"},{"location":"workbook/flowcharts/flowcharts/#segmentation","text":"Flow charts should at most take up one page. It is not acceptable for a flow chart to go over a page. Any flow chart taking up more than one page should be segmented into smaller flow charts. You can then combine them to construct a higher-level flow chart by referencing their IDs.","title":"Segmentation"},{"location":"workbook/schematic/schematic/","text":"Hardware Schematics Hardware schematics are meant to show how you would physically implement the stage/project design. Each hardware schematic diagram sheet must be pasted into your workbook. Each hardware schematic diagram sheet must have a unique ID (HID) that consists of the stage number and a unique ID for the hardware schematic - e.g. H1-2 is hardware schematic 2 from stage 1. The HID must be used when referring to the corresponding hardware schematic in your other hardware schematic diagram sheets. The hardware schematic should clearly show the inputs and outputs to the embedded platform and the peripherals in use. Wires or signals are represented as a single lines. A BUS is a collection of wires that all starts at the same peripheral and then all terminates at the same peripheral. Where possible use a double line to represent a Bus. Figure 1: Hardware Schematic Bus Example Each wire or bus must have the start and end terminals labeled, e.g. what pins are connected. You must draw peripherals with standard logic symbols and each peripheral must be labeled. The schematic must be legible and neatly drawn. Figure 2: Hardware Schematic Example Logic Symbols IEEE distinctive logic symbols (e.g. NOT, AND, OR, etc) must be used when drawing a block diagram. If there is no distinctive symbol used, then a rectangular symbol can be used.Refer to the IEEE Standard Symbols PDF on Blackboard. Segmentation Each hardware schematic should take up a single page. If a large design takes up more than one page, you must segment your design into separate hardware schematic blocks with unique HIDs, then combine them together in an overview schematic diagram. The overview hardware schematic shows each hardware schematic as a block (with HID). There should not be wires crossing pages.\\","title":"Hardware Schematics"},{"location":"workbook/schematic/schematic/#hardware_schematics","text":"Hardware schematics are meant to show how you would physically implement the stage/project design. Each hardware schematic diagram sheet must be pasted into your workbook. Each hardware schematic diagram sheet must have a unique ID (HID) that consists of the stage number and a unique ID for the hardware schematic - e.g. H1-2 is hardware schematic 2 from stage 1. The HID must be used when referring to the corresponding hardware schematic in your other hardware schematic diagram sheets. The hardware schematic should clearly show the inputs and outputs to the embedded platform and the peripherals in use. Wires or signals are represented as a single lines. A BUS is a collection of wires that all starts at the same peripheral and then all terminates at the same peripheral. Where possible use a double line to represent a Bus. Figure 1: Hardware Schematic Bus Example Each wire or bus must have the start and end terminals labeled, e.g. what pins are connected. You must draw peripherals with standard logic symbols and each peripheral must be labeled. The schematic must be legible and neatly drawn. Figure 2: Hardware Schematic Example","title":"Hardware Schematics"},{"location":"workbook/schematic/schematic/#logic_symbols","text":"IEEE distinctive logic symbols (e.g. NOT, AND, OR, etc) must be used when drawing a block diagram. If there is no distinctive symbol used, then a rectangular symbol can be used.Refer to the IEEE Standard Symbols PDF on Blackboard.","title":"Logic Symbols"},{"location":"workbook/schematic/schematic/#segmentation","text":"Each hardware schematic should take up a single page. If a large design takes up more than one page, you must segment your design into separate hardware schematic blocks with unique HIDs, then combine them together in an overview schematic diagram. The overview hardware schematic shows each hardware schematic as a block (with HID). There should not be wires crossing pages.\\","title":"Segmentation"},{"location":"workbook/state_diagram/state_diagram/","text":"State Diagrams State diagrams show the modes of operation of your program (or firmware). The firmware may enter different modes or stages of operation, e.g. reading the joystick or displaying the LED-Bar pattern. State diagrams are used to describe cyclic executives, such as the \\texttt{main()} function or an RTOS task/thread. Figure 1: State Diagram Example","title":"State Diagrams"},{"location":"workbook/state_diagram/state_diagram/#state_diagrams","text":"State diagrams show the modes of operation of your program (or firmware). The firmware may enter different modes or stages of operation, e.g. reading the joystick or displaying the LED-Bar pattern. State diagrams are used to describe cyclic executives, such as the \\texttt{main()} function or an RTOS task/thread. Figure 1: State Diagram Example","title":"State Diagrams"}]}